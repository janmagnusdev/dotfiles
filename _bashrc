# If not running interactively, don't do anything
[[ -z "$PS1" ]] && return

export HISTCONTROL=ignoredups:ignorespace
export HISTFILESIZE=10000
export HISTSIZE=10000
# export HISTIGNORE='ls:ll'

shopt -s checkwinsize
shopt -s histappend

export SIMPLE_PROMPT=0

# Prompt
function set_bash_prompt {
    # Get exit code of the last command
    LAST_CODE=$?
    P_EXIT_STATUS="$([[ $LAST_CODE != 0 ]] && echo "ℯ$LAST_CODE")"

    # Get the current time
    P_TIME="$(date '+%H:%M')"

    function _pwd_short {
        folder_icons=(
            "~/.dotfiles,󰒓"
            "~/Desktop,󰇄"
            "~/Documents,󰈙"
            "~/Downloads,󰇚"
            "~/Movies,󰎁"
            "~/Music,󰝚"
            "~/Nextcloud,󰇄"
            "~/Pictures,󰅟"
            "~/Projects,󱁤"
            "~/Videos,󰎁"
            "~,"
        )

        current_path=${PWD/#$HOME/'~'}
        for i in ${folder_icons[@]}; do
            KEY="${i%,*}"
            VAL="${i#*,}"
            current_path="${current_path/#${KEY}/${VAL} }"
        done

        path_len=${#current_path}
        max_path_len=$(( $COLUMNS - 75 ))  # "70" is a rough estimate for the remainderof the prompt
        if [[ ! $current_path =~ / ]] || (( $path_len <= $max_path_len )); then
            echo $current_path
        else
            # See: https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion
            directory="${current_path##*\/}"  # basename
            parent_path="${current_path%\/*}"  # dirname
            # Shorten paths with 4 or more characters ("xxxx" -> "xx…", but "xxx" => "xxx")
            parent_path_short="$(echo "$parent_path" | sed -r 's|/([^/]{2})[^/]{2,}|/\1…|g')"
            echo "$parent_path_short/$directory"
        fi
    }
    P_PATH="${PWD/#$HOME/'~'}"
    P_PATH_SHORT="$(_pwd_short)"

    # Get version control status
    function _prompt_vc_status {
        if hash vcprompt &>/dev/null; then
            echo "$(vcprompt)"
            # echo "$(vcprompt --minimal)"
        fi
    }
    P_VCSTATUS="$(_prompt_vc_status)"

    # Get names of active virtual/conda envs
    export CONDA_CHANGEPS1=0
    export VIRTUAL_ENV_DISABLE_PROMPT=1
    P_VENV="$([[ -n "$VIRTUAL_ENV" ]] && echo "${VIRTUAL_ENV##*/}")"
    P_CONDAENV="$([[ -n "$CONDA_PREFIX" ]] && echo "${CONDA_DEFAULT_ENV}")"

    declare -A COLORS
    COLORS[reset]="0"
    COLORS[normal]="22;39"
    COLORS[bold]="1"
    COLORS[italic]="3"
    COLORS[reverse]="7"
    COLORS[black]="30"
    COLORS[red]="31"
    COLORS[green]="32"
    COLORS[yellow]="33"
    COLORS[blue]="34"
    COLORS[purple]="35"
    COLORS[cyan]="36"
    COLORS[white]="37"
    COLORS[bright_black]="90"
    COLORS[bright_red]="91"
    COLORS[bright_green]="92"
    COLORS[bright_yellow]="93"
    COLORS[bright_blue]="94"
    COLORS[bright_purple]="95"
    COLORS[bright_cyan]="96"
    COLORS[bright_white]="97"
    COLORS[bg_black]="40"
    COLORS[bg_red]="41"
    COLORS[bg_green]="42"
    COLORS[bg_yellow]="43"
    COLORS[bg_blue]="44"
    COLORS[bg_purple]="45"
    COLORS[bg_cyan]="46"
    COLORS[bg_white]="47"
    COLORS[bg_bright_black]="100"
    COLORS[bg_bright_red]="101"
    COLORS[bg_bright_green]="102"
    COLORS[bg_bright_yellow]="103"
    COLORS[bg_bright_blue]="104"
    COLORS[bg_bright_purple]="105"
    COLORS[bg_bright_cyan]="106"
    COLORS[bg_bright_white]="107"

    function c {
        # echo -n "\[\e[${COLORS[$bold]};${COLORS[$fg]};${COLORS[$bg]}m\]"
        echo -n "\[\e["
        for arg in $@; do
            echo -n ";${COLORS[$arg]}"
        done
        echo "m\]"
    }

    function lcap {
        fg="$1"
        bg="${2-}"
        echo -n "$(c "$fg" "$bg")"
    }
    function rcap {
        fg="$1"
        bg="${2-}"
        echo -n "$(c "$fg" "$bg")"
    }
    function sep {
        if [[ $1 == 1 ]]; then
            echo " |"
        fi
    }

    C_TIME="yellow"
    C_USER="green"
    if [[ -n "${SSH_CLIENT-}${SSH2_CLIENT-}${SSH_TTY-}" ]]; then
        IS_SSH=1
        C_HOST="purple"
    else
        IS_SSH=0
        C_HOST="cyan"
    fi
    C_PATH="blue"
    C_INFO="bright_black"
    C_VENV="purple"
    C_CONDAENV="cyan"
    C_ERR="red"

    PS1="\[\033[G\]"  # http://jonisalonen.com/2012/your-bash-prompt-needs-this/
    PS1+="\n"                       # empty line above prompt

    if [[ $SIMPLE_PROMPT == 0 ]]; then
        # Prepare sections beforehand so that we can later determine the
        # proper cap style.
        # Section: time
        SEC_TIME="$(c reverse $C_TIME)  $P_TIME "
        # Section: user and host
        if [[ $USER == stefan ]] && [[ $IS_SSH == 0 ]]; then
            SEC_HOST="$(c reverse $C_HOST) $OSSYMBOL "
        else
            SEC_HOST="$(c reverse $C_HOST) $OSSYMBOL \u@\h "
        fi
        # Section: cwd
        SEC_PATH="$(c reverse $C_PATH) $P_PATH_SHORT "
        # Section: info (vc status, venv, ...)
        SEC_INFO=""
        if [[ -n $P_VCSTATUS ]]; then
            SEP=1
            SEC_INFO+="$(c reset bg_$C_INFO)$P_VCSTATUS"
        else
            SEP=0
        fi
        if [[ -n $P_VENV ]]; then
            SEC_INFO+="$(c reset bg_$C_INFO)$(sep $SEP) 󰌠 $(c $C_VENV bg_$C_INFO)$P_VENV"
            SEP=1
        fi
        if [[ -n $P_CONDAENV ]]; then
            SEC_INFO+="$(c reset bg_$C_INFO)$(sep $SEP) 󰌠 $(c $C_CONDAENV bg_$C_INFO)$P_CONDAENV"
            SEP=1
        fi
        # Section: exit code of last command
        SEC_EXIT=""
        if [[ -n $P_EXIT_STATUS ]]; then
            SEC_EXIT+="$(c reverse $C_ERR) $P_EXIT_STATUS"  # exit code
        fi

        # Concatenate the sections and join them with right caps
        PS1+="$SEC_TIME"
        PS1+="$(rcap $C_TIME bg_$C_HOST)"
        PS1+="$SEC_HOST"
        PS1+="$(rcap $C_HOST bg_$C_PATH)"
        PS1+="$SEC_PATH"
        CAP_FG="$C_PATH"
        if [[ -n $SEC_INFO ]]; then
            PS1+="$(rcap $CAP_FG bg_$C_INFO)"
            PS1+="$SEC_INFO"
            CAP_FG="$C_INFO"
        fi
        if [[ -n $SEC_EXIT ]]; then
            PS1+="$(rcap $CAP_FG bg_$C_ERR)"
            PS1+="$SEC_EXIT"
            CAP_FG="$C_ERR"
        fi
        PS1+="$(rcap $CAP_FG)"

        # The actual prompt
        # PS1+="$(c reset)\n$(c bright_blue) $(c white)"
        PS1+="$(c reset)\n$(c bright_blue) $(c white)"
        PS2="$(c blue)· $(c white)"
        PS0="$(c reset)"
    else
        # PS1+="$(c $C_TIME)[$P_TIME]$(c reset) "  # current time
        PS1+="$(c bold $C_USER)\u"  # user
        PS1+="$(c reset)@"          # @
        PS1+="$(c bold $C_HOST)\h"  # host
        PS1+="$(c reset):"          # :
        PS1+="$(c bold $C_PATH)\w"  # cwd
        PS1+="$(c reset)"
        PS1+="$P_VCSTATUS"          # repo stats
        if [[ -n $P_VENV ]]; then
            PS1+=" ($(c $C_VENV)$P_VENV$(c reset))"  # venv
        fi
        if [[ -n $P_CONDAENV ]]; then
            PS1+=" ($(c $C_CONDAENV)$$P_CONDAENV$(c reset))"  # conda env
        fi
        if [[ -n $P_EXIT_STATUS ]]; then
            PS1+=" $(c $C_ERR)$P_EXIT_STATUS$(c reset)"  # exit code
        fi
        PS1+="$(c reset)\n$(c bright_blue)\$ $(c white)"
        PS2="$(c blue)> $(c white)"
        PS0="$(c reset)"
    fi
}

PROMPT_COMMAND=set_bash_prompt

# make less more friendly for non-text input files, see lesspipe(1)
[[ -x /usr/bin/lesspipe ]] && eval "$(SHELL=/bin/sh lesspipe)"

# enable color support of ls and also add handy aliases
if [[ -x /usr/bin/dircolors ]]; then
    # test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias diff='diff --color=auto'
fi
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# https://geoff.greer.fm/lscolors/
export LSCOLORS=ExGxFxDxCxHxHxacagaeaf
export LS_COLORS="di=1;34:ln=1;36:so=1;35:pi=1;33:ex=1;32:bd=1;37:cd=1;37:su=30;42:sg=30;46:tw=30;44:ow=30;45"

# OS X color terminal
export CLICOLOR=1

# Python start-up and virtualenv wrapper
export PYTHONSTARTUP=$HOME/.pythonrc
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON="$HOMEBREW_PREFIX/bin/python3"
venwrap=$(type -P virtualenvwrapper.sh)
if [[ $venwrap != '' ]]; then
    . $venwrap
fi

# Load autojump if installed
if [[ -s /usr/share/autojump/autojump.bash ]]; then  # Ubuntu
    . /usr/share/autojump/autojump.bash
elif [[ -s $HOMEBREW_PREFIX/etc/profile.d/autojump.sh ]]; then  # homebrew
    . $HOMEBREW_PREFIX/etc/profile.d/autojump.sh
fi

# Alias definitions.
if [[ -f ~/.bash_aliases ]]; then
    . ~/.bash_aliases
fi

# Source stuff from secret private directory ...
if [[ -d ~/.private ]]; then
    . ~/.private/bash_aliases.sh
fi

# Source bash-completion
# Should be at the end to take updated XDG_DATA_DIRS into account.
OS_NAME="$(uname -s)"
if [[ $OS_NAME == "Darwin" ]]; then
    if [[ -f $HOMEBREW_PREFIX/etc/bash_completion ]]; then
        . $HOMEBREW_PREFIX/etc/bash_completion
    fi

elif [[ $OS_NAME == 'Linux' ]]; then
    . /usr/share/bash-completion/bash_completion
fi
if type -P op > /dev/null; then
    source <(op completion bash)
fi

# direnv
if type -P direnv > /dev/null; then
    eval "$(direnv hook bash)"
fi
